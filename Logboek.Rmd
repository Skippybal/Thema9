---
title: "Logboek"
author: "Kasper Notebomer"
date: "9/14/2021"
output:
  pdf_document: 
    extra_dependencies: ["flafter"]
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Setup of the libraries.
```{r, message=FALSE, warning=FALSE}
# Libraries
library("ggplot2")
library("kableExtra")
library("factoextra")
library("cowplot")
library("gridExtra")
library("dplyr")
library(ggpubr)
library(ggfortify)
library(tidyr)
library(purrr)
library(ggcorrplot)
library(reshape2)
```

<!-- * Copyright (c) 2018 Kasper Notebomer. -->
<!-- * Licensed under GPLv3. See gpl.md -->



# Introduction
The data was provided by Tsjerk Wassenaar of the RuG. The data set contains data on membrane composition and characteristics. The data set is not publicly available. The data set also does not have a publication linked to it.

Seeing as there is no paper linked to the data set I can only guess using the information that I did get that the data was gathered by making a membrane using specific variables and the measuring the resulting membranes to get variables like the thickness and compressibility.
The data set contains 14 variables and 2843 different measurement. The goal is to use measurement to predict the composition of the membrane. 
Typically you would use independent variables to predict one dependent variable. In this data set this doesn't seem to be the case, seeing as the variables that are given as parameters are seen as class variables, this means that these would be considered the labels. The parameters are: Temperature, Sterol type, Sterol concentration, Other (phospho)lipids in membrane, Aliphatic tails, Saturation index, Phosphatidyl choline concentration and Ethanol concentration. So the biggest question that the EDA should anwser is which of these variables is most interesting to use as the label, or could we even predict multiple of them using the save variables.

# Data exploration

## Data reading & codebook
To start off the data is read in using read.csv(). The data frame that is created by this step is turned into a tibble and then used to create a codebook. The codebook is a csv file that contains the abbreviation, type and the description of every variable in the data set.
```{r Data reading & structure}
# Read the data and transform it to a tibble
data <- read.csv("data/dataFrame_all_sims.csv", 
                 sep = ",", header=TRUE, 
                 stringsAsFactors=FALSE)
data <- as_tibble(data)
```

Here, the codebook is made of all of the abbreviations in the data frame, their meaning and their type.
```{r Codebook}
# Create the codebook
codebook <- data.frame("Abbreviation" = colnames(data), "Type" = sapply(data, typeof), 
                       "Class" = sapply(data, class),
                       "Desciption" = c("Temperature (Kelvin)",
                                        "Sterol type", 
                                        "Sterol concentration (%)",
                                        "Other (phospho)lipids in membrane (headgroup)",
                                        "Aliphatic tails",
                                        "Saturation index (double bonds per tail)", 
                                        paste("Phosphatidyl choline concentration",
                                              "(% of non-sterol lipids)"), 
                                        "Ethanol concentration (% of solvent)",
                                        "Area per lipid (nm^2)", 
                                        "Thickness (nm)", "Bending rigidity (kB T)",
                                        "Tilt angle (degrees)", 
                                        "Z-order", "Compressibility (cN / m)"),
                       "Units" = c("Kelvin",
                                   "", 
                                   "%",
                                   "",
                                   "",
                                   "", 
                                   "", 
                                   "",
                                   "nm^2", 
                                   "nm",
                                   "kB T",
                                   "degrees", 
                                   "", 
                                   "cN / m"))
# Turn dataframe into a tibble
codebook <- as_tibble(codebook)
kable(codebook, caption = "Codebook") %>%
  kable_styling(latex_options = c("scale_down", "hold_position"))

# Write codebook to .csv file
write.csv(codebook, "data/codebook.csv", row.names = FALSE)
```
The codebook, shown in table 1, seems to have all of the correct data and datatypes. To easily access the description based on the abbreviation the following function is used.
```{r Codebook function}
# Get the description by the abbreviation from the codebook
get_des_by_ab <- function(df, abbreviation){
  description <- df[df$Abbreviation == abbreviation,]$Desciption
  return(description)
}
```


## Structure & summary


Here I'll take a look at the structure and the five number summary of the data to look for any problems or discrepancies. 

```{r Structure}
# Print the structure of the data
data.frame(variable = names(data),
           classe = sapply(data, class),
           first_values = sapply(data, function(x) paste0(head(x),  collapse = ", ")),
           row.names = NULL) %>% 
  kable(caption="Data structure")  %>%
  kable_styling(latex_options = c("scale_down", "hold_position"))

```
Looking at the structure of the data, shown in table 2, it seems like all of the columns have been read and have the right datatype.

```{r Five number summary}
# Get the five number summary of the selected columns
sum <- summary(data[c("temperature","sterol.conc","satur.index",
                      "PC.conc","ethanol.conc","APL", "thickness", "bending",
                      "tilt", "zorder","compress")])

sum <- sub(".*:", "", sum)
sum[is.na(sum)] <- 0
rownames(sum) <- c("Minimum", "Q1", "Median", "Mean", "Q3", "Maximum", "Number of NA's")

# Print five number summary using kable
kable(sum, caption="Five number summary") %>%
  kable_styling(latex_options = c("scale_down", "hold_position"))
```
Looking at the structure there doesn't seem to be immediate problem with the data, like the data being read as the wrong datatype. When looking at the five number summary, depicted in table 3, there do seem to be some rows that are missing values like the APL, thickness, bending and tilt values. These rows will be omitted for plotting and other research seeing as they can't be used.
The maximum of the bending rigidity and tilt angle seem to be too high, this probably means that these are outliers seeing as the rest of the values in the summary seem to be believable. To check this we'll make a histogram of these variables.

```{r "Omit NA's"}
# Remove NA's
row.has.na <- apply(data, 1, function(x){any(is.na(x))})
nona_data <- na.omit(data)
row.has.na.2 <- apply(nona_data, 1, function(x){any(is.na(x))})
paste("Number of NA's before: ", sum(row.has.na),
", Number of NA's after:", sum(row.has.na.2), sep="")
```
`r sum(row.has.na) - sum(row.has.na.2)` lines with NA's where omitted from the data set.


```{r Histograms}
# Create 4 histograms
p <- ggplot(nona_data, aes(x= bending)) + 
  geom_histogram(binwidth=5) +
  ggtitle("Bending rigidity histogram")
p2 <- ggplot(nona_data, aes(x=tilt)) + 
  geom_histogram(binwidth=5) +
  ggtitle("Tilt angle histogram")
p3 <- ggplot(nona_data, aes(x= log10(bending + 1))) + 
  geom_histogram(binwidth=0.1) +
  ggtitle("Log10 bending rigidity histogram")
p4 <- ggplot(nona_data, aes(x=log10(tilt + 1))) + 
  geom_histogram(binwidth=0.1) +
  ggtitle("Log10 tilt angle histogram")
plots <- ggarrange(p, p2, p3, p4,
                   labels = c("A", "B", "C", "D"),
                   ncol = 2, nrow = 2)
title <- expression(atop(bold("Figure 1:"), 
                         scriptstyle("Histograms of bending rifidity and tilt angle")))
annotate_figure(plots,
                top=text_grob(title))
```
Both the bending and the tilt variable seem to have a lot of outliers when looking at figure 1. Even when transformed using log10 they still seem to be quite skewed. This is something we need to keep in mind in future research.


# Exploring relations between variables
## Density plot

I will now make density plots of some of the variables to see whether or not they look promising in finding class distinctions. These density plots will also make any skewing in the data apparent.
```{r Density}
# Create density plots
p <- ggplot(nona_data, aes(x=bending, colour = factor(sterol.type))) + 
  geom_density() +   
  xlab(get_des_by_ab(codebook, "bending")) + 
  ylab("Density") +
  ggtitle("Bending rigidity density plot") + 
  labs(colour = get_des_by_ab(codebook, "sterol.type"))

p2 <- ggplot(nona_data, aes(x=APL, colour = factor(sterol.type))) + 
  geom_density() +
  xlab(get_des_by_ab(codebook, "APL")) + 
  ylab("Density") +
  ggtitle("Area per lipid density plot") + 
  labs(colour = get_des_by_ab(codebook, "sterol.type"))

p3 <- ggplot(nona_data, aes(x=compress, colour = factor(sterol.type))) + 
  geom_density() +
  xlab(get_des_by_ab(codebook, "compress")) + 
  ylab("Density") +
  ggtitle("Compressibility density plot") + 
  labs(colour = get_des_by_ab(codebook, "sterol.type"))

p4 <- ggplot(nona_data, aes(x=APL, colour = factor(tails))) + 
  geom_density() +   
  xlab(get_des_by_ab(codebook, "APL")) + 
  ylab("Density") +
  ggtitle("APL density") + 
  labs(colour = get_des_by_ab(codebook, "tails"))
```

```{r Density plot arrangement, fig.cap="Density plots of bending rigidity, APL and compressability"}
# Plot density plots
plots <- ggarrange(p, p2, p3, p4,
                   labels = c("A", "B", "C", "D"),
                   ncol = 2, nrow = 2)
title <- expression(atop(bold("Figure 2:"), 
                         scriptstyle(paste("Density plots of multiple",
                                           " variables coloured on sterol type"))))
annotate_figure(plots,
                top=text_grob(title))
```
Plot A in figure 2 show that there is basically no distinction between cholesterol and ergosterol based on the bending rigidity. However, distinction between no sterol or a sterol does seem to be possible based on the bending rigidity seeing as the peaks of there classes only overlaps a small bit. There does seem to be an odd peak in the no sterol class at around 50 kB/t bending rigidity.

In plot B it looks like there is absolutely no way of distinguishing different classes based on the area per lipid, seeing as the peaks are basically in the same place. But just to be certain we'll still plot in against some other variables to make sure, seeing as it might be a very useful variable when paired with something like bending rigidity.
The results depicted in plot C also don't look very promising seeing as every peak is around the same place again.
Plot D on the other hand seems a lot more interesting seeing as all of the peaks are in slightly different locations, the DO, PO and the PI seem to overlap a lot but the DP and DI tails seem to have little overlap with the rest. It seems like APL could possibly be used as a variable to distinguish between aliphatic tails when paired with another variable.

When looking at all of the plots it looks like most of the data is skewed in one way or another, even though when we looked at the structure there didn't seem to be much. This can probably be explained by the extra dimension that was added in these plots, the sterol type and the aliphatic tails.


## Scatter plot
```{r Pairs, eval=FALSE}
# Code not run
# Results are too big and too clumpy for the analysis
pairs(nona_data,
      panel = "panel.smooth",
      pch = 20, 
      cex = 0.35,
      col = rgb(0.1, 0.4, 1, alpha = 0.4))
```
This code is for a paired scatter plot. The eval is currently set to false seeing as there are a lot of variables that are compared to each other in this data set. Running this code will result in a big plot that isn't very well interpretable in a pdf file.

First we'll plot the bending area per lipid against the rigidity of the membrane, colouring the points based on the sterol type, to look for any kind of clustering or correlation. To make it even cleared we'll also make a second plot with a loess regression. The reason we use loess regression instead of linear regression is because loess will show us a better trend line, seeing as it isn't trying to fit a straight line like linear regression. 

```{r APL Bending plot}
#Plot APL against bending rigidity
chart <- ggplot(nona_data, aes(APL, bending, colour = factor(sterol.type) )) + 
  geom_point(alpha=1/10, size=0.5) + 
  xlab(get_des_by_ab(codebook, "APL")) + 
  ylab(get_des_by_ab(codebook, "bending")) + 
  theme(axis.title.y = element_text(size=8)) + 
  ggtitle("APL against bending rigidity scatter plot") + 
  labs(colour = get_des_by_ab(codebook, "sterol.type"))

plots <- ggarrange(chart,
                   chart + 
                     geom_smooth(method = "loess") + ggtitle(""),
                   labels = c("A", "B"),
                   ncol = 1, nrow = 2)

title <- expression(atop(bold("Figure 3:"), 
                         scriptstyle(paste("APL against bending rigidity,", 
                                           " with and without loess regression"))))
# Give the plot a number
annotate_figure(plots,
                top=text_grob(title))
```
Looking at the plots in figure 3 we can see that there is a clear separation in the area per lipid to bending rigidity ratio when comparing no sterol present to both cholesterol and ergosterol. When comparing cholesterol and ergosterol we can't see such a clear separation, there seems to be a lot of overlap. There are also a few outliers that are barely visible at area per lipid 0.4 and bending rigidity 0.
The correlation seem to inverse logarithmic, so to check this I'll make a plot where the bending rigidity is log transformed.

```{r Log10 APL bending plot}
# Create plot
chart <- ggplot(nona_data, aes(APL, log10(bending + 1), colour = factor(sterol.type) )) + 
  geom_point(alpha=1/10, size=0.5) + 
  xlab(get_des_by_ab(codebook, "APL")) + 
  ylab(paste( "Log10 ", get_des_by_ab(codebook, "bending"))) + 
  geom_smooth(method = "loess") + 
  ggtitle("APL against log10 bending rigidity scatter plot") + 
  labs(colour = get_des_by_ab(codebook, "sterol.type"))

# Plot the Plot and add a tag
chart + labs(tag = "Figure 4: APL against log transformed bending regidity") +
      theme(plot.title = element_text(hjust = 0.5),
          plot.margin = margin(t = 10, r = 10, b = 40, l = 10),
          plot.tag.position = c(0.4, -0.1)
          )
```
Looking at figure 4 we can see that there indeed seem to be an almost linear correlation between the log10 transformed bending rigidity and the area per lipid. There does still seem to be a sleight curve in all of the trend lines when the area per lipid increases.

Here I'll plot the temperature against the bending rigidity while colouring based on saturation index, and deciding the shape based on the sterol type.
```{r Temp x bening regidity}
# Create rectangles to fit over the plot
rects <- data.frame(xstart = seq(0,600,300), xend = seq(300,900,300), col = letters[1:3])

# Create the plot
chart <- ggplot(nona_data, aes(temperature, bending, colour = factor(satur.index),
                               shape = factor(sterol.type) )) + 
  geom_jitter(alpha=1/10) +   
  xlab(get_des_by_ab(codebook, "temperature")) + 
  ylab(get_des_by_ab(codebook, "bending"))  + 
  ggtitle("Temperature against bending regidity, 
          coloured by saturation index, shaped on sterol type") + 
  theme(plot.title = element_text(size=10)) + 
  labs(colour = get_des_by_ab(codebook, "sterol.type"),
       shape = get_des_by_ab(codebook, "satur.index"))

# Print the plot and add 2 boxes for the 2 groups in the temperature variable 
chart + 
  geom_rect(aes(xmin = -Inf, xmax = 312.9, ymin = -Inf, ymax = Inf), 
            color="orange",
            fill = "green", alpha = 0.0001) + 
  geom_rect(aes(xmin = 313.1, xmax = Inf, ymin = -Inf, ymax = Inf), 
            color="purple",
            fill = "yellow", alpha = 0.0001) +
  labs(tag = "Figure 5: Temperature against bending regidity") +
  theme(plot.title = element_text(hjust = 0.5),
        plot.margin = margin(t = 10, r = 10, b = 40, l = 10),
        plot.tag.position = c(0.35, -0.1)
        )
```
When looking at the plot in figure 5, there seem to be a clear separation between a saturation index of 0 while the rest of the values seem to be clustered quite close together. There does seem to be a small separation between 0.5, 1 and 2 values. An interesting observation is that there don't seem to be any data point with a saturation index of more than 0.5 in the 328 kelvin group (the purple box).

Here the APL will be plot against the bending rigidity again, but here the colour is decided based on the saturation index and the shape on the sterol type.
```{r}
# Create plots
chart2 <- ggplot(nona_data, aes(APL, bending, colour = factor(satur.index), shape = factor(sterol.type) )) + 
  geom_jitter(alpha=1, size=0.5) +  
  xlab(get_des_by_ab(codebook, "APL")) + 
  ylab(get_des_by_ab(codebook, "bending"))  + 
  ggtitle("APL against bending regidity, 
          coloured on saturation index, shaped on sterol type") + 
  theme(plot.title = element_text(size=10))
chart2 + labs(colour = get_des_by_ab(codebook, "satur.index"), shape = get_des_by_ab(codebook, "sterol.type")) +
  labs(tag = "Figure 6: APL against bending rigidity coloured on saturation index") +
  theme(plot.title = element_text(hjust = 0.5),
        plot.margin = margin(t = 10, r = 10, b = 40, l = 10),
        plot.tag.position = c(0.4, -0.1)
        )
```
In figure 6 we can see the same kind of correlation as before, but now we can see that there also seem to be some kind of clustering based on the saturation index.

Here is a plot that shows the compressibility plotted against the bending rigidity.
```{r bending compress plot, warning=FALSE}
# Create plot
chart <- ggplot(nona_data, aes(compress, bending, colour = factor(sterol.type) )) +
  geom_point(alpha=2/10, size=0.5) +
  xlab(get_des_by_ab(codebook, "compress")) +
  ylab(get_des_by_ab(codebook, "bending")) +
  theme(axis.title.y = element_text(size=8)) +
  ggtitle("Compressibility against bending rigidity,
          coloured on sterol type") +
  labs(colour = get_des_by_ab(codebook, "sterol.type"))  +
  theme(plot.title = element_text(size=10))

chart2 <- ggplot(nona_data, aes(compress, bending, colour = factor(sterol.type) )) +
  geom_point(alpha=2/10, size=0.5) +
  xlab(get_des_by_ab(codebook, "compress")) +
  ylab(get_des_by_ab(codebook, "bending")) +
  theme(axis.title.y = element_text(size=8)) +
  ggtitle("Compressibility against bending rigidity,
          coloured on sterol type, zoomed in") +
  labs(colour = get_des_by_ab(codebook, "sterol.type")) +
  scale_x_continuous(limits=c(0,120)) +
  scale_y_continuous(limits=c(0, 45))  +
  theme(plot.title = element_text(size=10))

# Arrange plots
plots <- ggarrange(chart,
                   chart2,
                   labels = c("A", "B"),
                   ncol = 1, nrow = 2) 

title <- expression(atop(bold("Figure 7:"), 
                         scriptstyle("Compressibility against bending rigidity, full and zoomed")))
annotate_figure(plots,
                top=text_grob(title))
```
In plot A of figure 7 we can't really make out much of a pattern in the dense clout to the left, but when looking at the rest of the data points there does seem to be some grouping based on whether or not no sterol or a sterol is present. When zooming in in plot B we can now see the same kind of grouping happen again based on either a sterol present or no sterol present.



## Heatmap

Here a heatmap is made to look for correlation between variables.
```{r Heatmap independent variables}
# Get correlation
correlation <- nona_data[,9:14]
melted_cormat <- melt(cor(correlation))

ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() + 
  ggtitle("Heatmap of the variables") +
  labs(tag = "Figure 8: Heatmap of the independent varaibles") +
  theme(plot.title = element_text(hjust = 0.5),
        plot.margin = margin(t = 10, r = 10, b = 40, l = 10),
        plot.tag.position = c(0.5, -0.1)
        )
```
The results shown in figure 8 are very interesting. It seems like all of the variables seem to be quite heavily correlated, except for APL, which is negatively correlated. It also seem like the comprehensibility is slightly less correlated then the rest of the variables. But thickness, bending, tilt and z order all seem to be heavily correlated.

# PCA
Here we'll make a PCA plot to look for possible clusters.
```{r PCA, warning=FALSE}
# PCA plot results
pca_res <- prcomp(correlation, scale. = TRUE, center = TRUE)
print(pca_res)

# Create PCA plot
plots <- ggarrange(autoplot(pca_res, data = nona_data,
                            colour = 'sterol.type', alpha=2/10, 
                            size = 5/10) + 
                     ggtitle("PCA plot") +
                     labs(colour = get_des_by_ab(codebook, "sterol.type")),
                   autoplot(pca_res, data = nona_data, 
                            colour = 'sterol.type', alpha=1/5, 
                            size = 1/2) + 
                     ggtitle("PCA plot zoomed in") + 
                     labs(colour = get_des_by_ab(codebook, "sterol.type")) +
                     scale_x_continuous(limits=c(-0.03,0.025)) +
                     scale_y_continuous(limits=c(-0.03,0.04)),
                   labels = c("A", "B"),
                   ncol = 1, nrow = 2)
# Add title
title <- expression(atop(bold("Figure 9:"), 
                         scriptstyle("PCA plot using autoplot")))
annotate_figure(plots,
                top=text_grob(title))
```
In plot A of figure 9 we can hardly see any clusters at all, it does seem to have a dense cloud to the right. Plot B cuts off the data point on the side and zooms in on the dense cloud of dots visible in plot A, a total of 271 dots aren't visible because of this. In this plot we can't really make out much of a pattern or cluster. It does, however, seem like no sterol cluster is sleightly seperated from the other sterol types.

Here is another way to make a PCA plot that is a bit more advanced seeing as it will also give us a way to identify correlation based on variables in the clustering.
```{r PCA2}
# Create PCA plot
res.pca <- prcomp(correlation, scale = TRUE)
plot1 <- fviz_eig(res.pca) + 
  theme(axis.title.y = element_text(size=6))
plot2 <- fviz_pca_var(res.pca,
                      col.var = "contrib", # Colour by contributions to the PC
                      gradient.cols = c("orange", "purple"),
                      repel = TRUE     # Avoid text overlapping
                      ) 
plot3 <- fviz_pca_biplot(res.pca, repel = FALSE,
                         col.var = "purple", # Variables colour
                         col.ind = nona_data$sterol.type,  # Individuals colour
                         label = FALSE,
                         addEllipses =  TRUE,
                         ellipse.type = "t"
                         )
# Arrange plots
plot <- arrangeGrob(plot1,  plot2,
                    plot3,
                    ncol = 2, nrow = 2, 
                    layout_matrix = rbind(c(1,2), c(3,3)))

plot <- as_ggplot(plot) +
  draw_plot_label(label = c("A", "B", "C"), size = 15,
                  x = c(0, 0.5, 0), y = c(1, 1, 0.5))
title <- expression(atop(bold("Figure 10:"), 
                         scriptstyle("PCA results using fviz_eig")))
annotate_figure(plot,
                top=text_grob(title))
```
The PCA plots, B and C, shown in figure 10 confirms what we could already see in the heat map, that is that most of the variables seem to be heavily correlated, seeing as they are pointing in the same direction, except for APL and compress. We can also see that thickness and z order are correlated just like tilt and bending. The PCA plot also still looks the same, only now it has as ellipse for clusters that was calculated using a t test. The ellipses all seem to overlap so there doesn't seem to be much clustering. 


# K means 
Here we'll use K-means clustering as a different technique to find possible clusters.
```{r K-means}
# Calculate K-means, set seed for reproducibility
set.seed(666)
km.res <- kmeans(scale(correlation), 3, nstart = 25)

# Dimension reduction using PCA
res.pca <- prcomp(correlation,  scale = TRUE)
ind.coord <- as.data.frame(get_pca_ind(res.pca)$coord)
ind.coord$cluster <- factor(km.res$cluster)
ind.coord$sterol.type <- nona_data$sterol.type
kable(head(ind.coord), caption="kmeans results") %>%
  kable_styling(latex_options = c("scale_down", "hold_position"))
```
The results in table 4 are printed to give a quick overview of the results of the K-means and to check for any possible problems. The row with sterol type is added so we can look whether or not this has anything to do with the found clusters.

```{r K-means2}
# Percentage of variance explained by dimensions
eigenvalue <- round(get_eigenvalue(res.pca), 1)
variance.percent <- eigenvalue$variance.percent
kable(head(eigenvalue), caption="Variance explained by dimensions") %>%
  kable_styling(latex_options = c("scale_down", "hold_position"))
```
In table 5 we can see the amount of variance is explained by ever dimension. Just like in the previous PCA plot we can see that over 80% of the variance is explained by a single variable, which is odd, to say the least.
```{r K-means3}
# Make pca plot based on K-means clusters
ggscatter(
  ind.coord, x = "Dim.1", y = "Dim.2", 
  color = "cluster", palette = "npg", ellipse = TRUE, ellipse.type = "convex",
  shape = "sterol.type", size = 1.5,  legend = "right", ggtheme = theme_bw(),
  xlab = paste0("Dim 1 (", variance.percent[1], "% )" ),
  ylab = paste0("Dim 2 (", variance.percent[2], "% )" )
) +
  stat_mean(aes(color = cluster), size = 4) +
  labs(tag = "Figure 11: PCA plot based on K-means clustering",
       shape = get_des_by_ab(codebook, "sterol.type")) +
  theme(plot.title = element_text(hjust = 0.5),
        plot.margin = margin(t = 10, r = 10, b = 40, l = 10),
        plot.tag.position = c(0.46, -0.1)
        )
```
This plot shown in figure 11 still doesn't seem very promising seeing as there seem to be three clear clusters, but this seems to be more because of the large spread of the data. The clusters also seem to have nothing to do with the sterol type of the membrane.

# Research question
Is it possible to use machine learning to reliably predicts the sterol type in a membrane with a higher than 80% accuracy, given the area per lipid, the bending rigidity and the compressibility? 
